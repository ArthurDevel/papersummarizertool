# Plan: Integrating BetterAuth for Magic Link Authentication

## 1. Overview & Goal

The primary goal is to implement a secure user authentication system using email-based magic links. This will allow users to log in to the application without a password. We will use the `BetterAuth` library for this purpose, integrating it directly into our existing infrastructure.

## 2. Core Architecture: Next.js as the Auth Gateway

A key aspect of this plan is how we integrate the authentication "server".

-   **No New Services**: We will **not** add a new service to `docker-compose.yml` or `supervisord`.
-   **Next.js API Routes**: The "server-side" logic for BetterAuth will live inside our existing Next.js `frontend` application as API Routes. The Next.js app will handle generating tokens, sending emails, and validating user sessions.
-   **Backend-for-Frontend (BFF)**: The Next.js application will act as a secure proxy, or gateway, for our Python backend. All traffic from a user's browser will go to the Next.js app first.

## 3. Critical Security: Backend Isolation

This is the most important security principle of this architecture.

-   **The Python backend must NOT be exposed to the public internet.**
-   Our `docker-compose.yml` configuration already enforces this by only publishing the port for the Next.js frontend (port `3000`). The Python API (port `8000`) is only accessible from within the internal Docker network.
-   This setup ensures that all requests to the backend must pass through the Next.js proxy, which is where we will enforce our authentication rules. Bypassing the authentication layer is not possible with this configuration.

## 4. How We'll Handle Public vs. Private Routes

The Next.js proxy will act as a smart gatekeeper, distinguishing between routes that require a user to be logged in and those that don't.

-   **Public Routes**: For endpoints that are public (e.g., searching for papers), the proxy will simply forward the request directly to the Python API without any checks.
-   **Private Routes**: For endpoints that are private (e.g., requesting a new paper summary), the proxy will first check if the user has a valid session cookie.
    -   If **authenticated**, the request is forwarded to the Python API. We can also securely pass the user's ID to the backend in a header.
    -   If **not authenticated**, the proxy will immediately block the request and return a `401 Unauthorized` error.

## 5. User Session Management

-   **Login Flow**: Users will enter their email on a login page. They will receive an email with a unique, single-use link. Clicking this link will sign them into the application.
-   **Secure Cookies**: Upon successful login, BetterAuth will set a secure, `HttpOnly` cookie in the user's browser. This cookie is automatically sent with every request to our Next.js application, but it cannot be accessed by client-side JavaScript, which protects against XSS attacks.
-   **Session Duration**: The session cookie will be configured to last for **30 days**. This means a user will remain logged in for a month before needing to sign in again, providing a smooth user experience.

## 6. High-Level Implementation Steps

1.  **Install Dependencies**: Add `@better-auth/magic-link` to the frontend.
2.  **Create Auth API Route**: Set up the BetterAuth server logic in a Next.js API route.
3.  **Configure Auth Client**: Create a client-side service for components to use.
4.  **Build UI**: Create the login and callback pages.
5.  **Implement API Proxy**: Build the selective proxy in Next.js to manage public and private routes to the Python backend.
6.  **Update Navigation**: Add login/logout links to the UI.
